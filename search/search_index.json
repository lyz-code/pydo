{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Pydo? \u00b6 pydo is a free software command line task manager built in Python . Why another CLI Task Manager? \u00b6 Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are many issues with how it handles recurrence . It doesn't have friendly task identifiers . There is no way of accessing the task time tracking from the python library. And lacks the following features: Native Kanban or Scrum support. Task estimations. Easy report creation. Easy way to manage the split of a task in subtasks. Freezing of recurrent tasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need. A quick demonstration \u00b6 Let's see pydo in action. We'll first add three tasks to our list. $: pydo add Buy milk [+] Added task 0: Buy milk $: pydo add Buy eggs [+] Added task 1: Buy eggs $: pydo add Bake cake [+] Added task 2: Bake cake Now let's see the list. $: pydo list \u2577 ID \u2502 Description \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 0 \u2502 Buy milk 1 \u2502 Buy eggs 2 \u2502 Bake cake \u2575 Suppose we bought our ingredients and wish to mark the first two tasks as done. $: pydo do 0 1 [+] Closed task 0: Buy milk with state done [+] Closed task 1: Buy eggs with state done $: pydo list \u2577 ID \u2502 Description \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 2 \u2502 Bake cake \u2575 Those are the first three features, the add , list and done commands, but they represent all you need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and more. Install \u00b6 To install pydo, run: pip install pydo The installation method will create a new pydo database at ~/.local/share/pydo/database.tinydb . pydo reads it's configuration from the yaml file located at ~/.local/share/pydo/config.yaml . The default template is provided at installation time. What's next? \u00b6 Probably the most important next step is to start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to change your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. If you want to contribute to the project follow this guidelines . Welcome to pydo . References \u00b6 As most open sourced programs, pydo is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to pydo , see Contributing to pydo .","title":"Overview"},{"location":"#what-is-pydo","text":"pydo is a free software command line task manager built in Python .","title":"What is Pydo?"},{"location":"#why-another-cli-task-manager","text":"Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are many issues with how it handles recurrence . It doesn't have friendly task identifiers . There is no way of accessing the task time tracking from the python library. And lacks the following features: Native Kanban or Scrum support. Task estimations. Easy report creation. Easy way to manage the split of a task in subtasks. Freezing of recurrent tasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need.","title":"Why another CLI Task Manager?"},{"location":"#a-quick-demonstration","text":"Let's see pydo in action. We'll first add three tasks to our list. $: pydo add Buy milk [+] Added task 0: Buy milk $: pydo add Buy eggs [+] Added task 1: Buy eggs $: pydo add Bake cake [+] Added task 2: Bake cake Now let's see the list. $: pydo list \u2577 ID \u2502 Description \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 0 \u2502 Buy milk 1 \u2502 Buy eggs 2 \u2502 Bake cake \u2575 Suppose we bought our ingredients and wish to mark the first two tasks as done. $: pydo do 0 1 [+] Closed task 0: Buy milk with state done [+] Closed task 1: Buy eggs with state done $: pydo list \u2577 ID \u2502 Description \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 2 \u2502 Bake cake \u2575 Those are the first three features, the add , list and done commands, but they represent all you need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and more.","title":"A quick demonstration"},{"location":"#install","text":"To install pydo, run: pip install pydo The installation method will create a new pydo database at ~/.local/share/pydo/database.tinydb . pydo reads it's configuration from the yaml file located at ~/.local/share/pydo/config.yaml . The default template is provided at installation time.","title":"Install"},{"location":"#whats-next","text":"Probably the most important next step is to start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to change your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. If you want to contribute to the project follow this guidelines . Welcome to pydo .","title":"What's next?"},{"location":"#references","text":"As most open sourced programs, pydo is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to pydo , see Contributing to pydo .","title":"Contributing"},{"location":"areas/","text":"Once you feel comfortable with the basic usage of pydo , you may want to explore the different features it has to adapt it to your workflow. As the number of tasks starts to increase, it's convenient to group them together to help us with the prioritization and visualization. One way of doing so is using areas. An area is an optional category that defines the purpose of a task, so a task can only have one area . If you feel that a task might need two areas or if you have hierarchical problems with your tasks, you may want to use tags instead. For example, you can use clean for cleaning tasks, or task_management for pydo developing tasks. To add a area to a task, use the area or ar keywords. pydo add Improve pydo documentation ar:task_management To see all the existing areas, use the areas report: $: pydo areas \u2577 Name \u2502 Open Tasks \u257a\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 None \u2502 2 task_management \u2502 1 \u2575 To change a task area use the mod command: pydo mod {{ task_filter }} ar:new_area","title":"Areas"},{"location":"basic_usage/","text":"All you need to know to use pydo effectively are these five commands ( add , do , rm , mod and open ). add \u00b6 To add a task run: pydo add Improve the pydo manual It's also possible to add tags or areas when creating a task: pydo add Improve the pydo manual ar:task_management +python open \u00b6 To see the open tasks run: pydo open By default, open is the default command, so you can run pydo alone. If you don't like the order of the tasks, you can sort them . do \u00b6 If you've completed a task, run: pydo do {{ task_filter }} Where {{ task_filter }} can be a task id extracted from the open report or a task expression like ar:task_management +python . rm \u00b6 If you no longer need a task, run: pydo del {{ task_filter }} mod \u00b6 To change existent tasks use the following syntax. pydo mod '{{ task_filter }}' {{ task_attributes }} Notice that the task_filter needs to be quoted if the filter contains more than one word. For example, to change the description of the first task, we'd do: pydo mod 0 Improve the pydo documentation If you are new to pydo , it's recommended that you stop here, start managing your tasks for a while. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might find what you need.","title":"Basic Usage"},{"location":"basic_usage/#add","text":"To add a task run: pydo add Improve the pydo manual It's also possible to add tags or areas when creating a task: pydo add Improve the pydo manual ar:task_management +python","title":"add"},{"location":"basic_usage/#open","text":"To see the open tasks run: pydo open By default, open is the default command, so you can run pydo alone. If you don't like the order of the tasks, you can sort them .","title":"open"},{"location":"basic_usage/#do","text":"If you've completed a task, run: pydo do {{ task_filter }} Where {{ task_filter }} can be a task id extracted from the open report or a task expression like ar:task_management +python .","title":"do"},{"location":"basic_usage/#rm","text":"If you no longer need a task, run: pydo del {{ task_filter }}","title":"rm"},{"location":"basic_usage/#mod","text":"To change existent tasks use the following syntax. pydo mod '{{ task_filter }}' {{ task_attributes }} Notice that the task_filter needs to be quoted if the filter contains more than one word. For example, to change the description of the first task, we'd do: pydo mod 0 Improve the pydo documentation If you are new to pydo , it's recommended that you stop here, start managing your tasks for a while. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might find what you need.","title":"mod"},{"location":"contributing/","text":"So you've started using pydo and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. The database schema is defined with SQLAlchemy objects and maintained with Alembic . To generate the testing data we use FactoryBoy with Faker . We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Finally, to ensure a quicker pull request resolution, remember to Allow edits from maintainers . Check Developing pydo to get better insights of the internals of the program. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import pydo.version; print(pydo.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install pydo or know it's not relevant to your question or feature request. Pull Requests \u00b6 pydo is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/pydo.git cd pydo Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install pydo, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: pydo uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to pydo !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. The database schema is defined with SQLAlchemy objects and maintained with Alembic . To generate the testing data we use FactoryBoy with Faker . We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Finally, to ensure a quicker pull request resolution, remember to Allow edits from maintainers . Check Developing pydo to get better insights of the internals of the program.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import pydo.version; print(pydo.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install pydo or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"pydo is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/pydo.git cd pydo Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install pydo, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: pydo uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to pydo !","title":"Development facilities"},{"location":"dates/","text":"A task does not require a due date: pydo add Send Alice a birthday card However these are the kind of tasks can benefit from having a due date. The due date \u00b6 Use the due task attribute to define the date by which a task needs to be completed. Using the previous example, you can set the due date to Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. To change the due date of a task use the mod command: pydo mod {{ task_id }} due: {{ new_due_date }} Date format \u00b6 pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the next operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Dates"},{"location":"dates/#the-due-date","text":"Use the due task attribute to define the date by which a task needs to be completed. Using the previous example, you can set the due date to Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. To change the due date of a task use the mod command: pydo mod {{ task_id }} due: {{ new_due_date }}","title":"The due date"},{"location":"dates/#date-format","text":"pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the next operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Date format"},{"location":"estimate/","text":"The estimate optional task attribute registers how many hours do you expect to spend on a task. In the Scrum methodology, assigning time estimate to tasks is a sin. Instead they use story points , which is an dimensionless quantity to compare tasks between themselves. The advantages of using story points is that you are not commiting to do a task in a specified amount of time and that it's easier to estimate if you are going to need more or less time to do a task than an other in relative terms. Once you complete several sprints , this estimate method is said to be more accurate. I've tried using story points in the past, but I find them unintuitive and useless when trying to improve your estimations. But as the estimate keyword accepts any float, you can use it to store story points . To set the estimate of a task use the est or estimate keyword: $: pydo add Task that takes 5 hours to complete est:5 [+] Added task 3: Task that takes 5 hours to complete Right now we only use the estimate for filtering or visualization purposes. But we plan to support reports to do data analysis on the difference between the estimation and the real time required to complete the task, so as to suggest estimation improvements.","title":"Estimate"},{"location":"export/","text":"All your data lives at the ~/.local/share/pydo/database.tinydb in json format, you can use it to migrate the data to other systems.","title":"Export"},{"location":"fun/","text":"The fun optional task attribute registers how much light-hearted pleasure, enjoyment, or amusement does the execution of the task gives. As with willpower , if your tasks have this property, it can help you determine the tasks to be done during the sprint and in what order so as not to burn yourself out. To set the value of a task use the fun keyword: $: pydo add Go hiking fun:4 [+] Added task 6: Go hiking As with the priority , I use a range of values from 0 to 5 but the parameter allows any integer.","title":"Fun"},{"location":"future_features/","text":"Design documentation for the features I'd love to create in the future. The game of life \u00b6 The goal is to measure the user state to suggest which kind of task are more suitable, raise alerts when the user reaches certain mental or physical states or give insights on the evolution of the user attributes. Domain Model \u00b6 User model \u00b6 We could model the state of a human with the following attributes groups: Mental attributes. Health attributes. Physical attributes. Skills. Traits. I've still not figured out how to vary the total attribute values over the time. Mental attributes \u00b6 Mental Energy: Measures the amount of mental work that you can do before getting fatigued. Vitality: Measures your life force of wanting to do things. For example, for me, dancing or doing work out is a task that increases my vitality, while staying in the couch for 5 hours watching tv shows kills my vitality. Tranquility : Measures the state of being calm, serene, and worry-free. As a side effect it measures the levels of stress and anxiety. Mental load : Measure of the invisible labor involved in managing yourself, a household and your closed ones, which typically falls on women's shoulders. Also sometimes referred to as worry work or cognitive labor , the mental load is about not the physical tasks but rather the overseeing of those tasks. It's being the one in charge of having the never-ending list of to-do items constantly running in your head, remembering what needs to get done and when, delegating tasks to others, and making sure they actually get done. One study describes it as the responsibility of anticipating needs, identifying options for filling them, making decisions, and monitoring progress. Pleasure : Measures the broad class of mental states that we experience as positive, enjoyable, or worth seeking. It includes more specific states such as happiness, entertainment, enjoyment, ecstasy and euphoria. Intelligence : Measures the capacity for logic, understanding, self-awareness, learning, emotional knowledge, reasoning, planning, creativity, critical thinking, and problem-solving. More generally, it's the ability to perceive or infer information, and to keep it as knowledge to be applied towards adaptive behaviors within an environment or context. Logic : Measures the systematic study of valid rules of inference, i.e. the relations that lead to the acceptance of one proposition (the conclusion) on the basis of a set of other propositions (premises). More broadly, logic is the analysis and appraisal of arguments. Understanding : Measures the psychological process related to an abstract or physical object, such as a person, situation, or message whereby one is able to think about it and use concepts to deal adequately with that object. Understanding is a relation between the knower and an object of understanding. Understanding implies abilities and dispositions in relation to an object of knowledge that are enough to support intelligent behavior. Self-awareness : Measures the experience of one's own personality or individuality. While consciousness is being aware of one's environment and body and lifestyle, self-awareness is the recognition of that awareness. Self-awareness is how an individual consciously knows and understands their own character, feelings, motives, and desires. Learning : Measures the process of acquiring new understanding, knowledge, behaviors, skills, values, attitudes, and preferences. Emotional Intelligence : Measures the ability of individuals to recognize their own emotions and those of others, discern between different feelings and label them appropriately, use emotional information to guide thinking and behavior, and manage and/or adjust emotions to adapt to environments or achieve one's goals. Reasoning : Measures the capacity of consciously making sense of things, applying logic, and adapting or justifying practices, institutions, and beliefs based on new or existing information. It's associated with such characteristically human activities as philosophy, science, language, mathematics, and art. Reason is sometimes referred to as rationality. Planning : Measures the process of thinking about the activities required to achieve a desired goal. It involves the creation and maintenance of a plan, such as psychological aspects that require conceptual skills. Creativity : Measures the ability to create something new and somehow valuable. The created item may be intangible (such as an idea, a scientific theory, a musical composition, or a joke) or a physical object (such as an invention, a printed literary work, or a painting). Critical Thinking : Measures the analysis of facts to form a judgment. It's the rational, skeptical, unbiased analysis, or evaluation of facts. Critical thinking is self-directed, self-disciplined, self-monitored, and self-corrective thinking. It presupposes assent to rigorous standards of excellence and mindful command of their use. It entails effective communication and problem-solving abilities as well as a commitment to overcome native egocentrism and sociocentrism. Problem Solving : Measure the ability to use generic or ad hoc methods in an orderly manner to find solutions to problems. Memory : Measures the faculty of the brain to encode, store and retrieve over the time data or information. Self-control : Measures the ability to regulate one's emotions, thoughts, and behavior in the face of temptations and impulses. As an executive function, self-control is a cognitive process that is necessary for regulating one's behavior in order to achieve specific goals. Self-regulation, whether emotional or behavioral, is a limited resource which functions like energy. In the short term, overuse of self-control will lead to depletion. In the long term, the use of self-control can strengthen and improve over time. Social interaction : Measures the amount of relationship you can endure with other human beings. Wisdom : Measures the ability to think and act using knowledge, experience, understanding, common sense and insight. It's associated with attributes such as unbiased judgment, compassion, experiential self-knowledge, self-transcendence and non-attachment, and virtues such as ethics and benevolence. Charisma : Measures the force of personality, persuasiveness and leadership. Health attributes \u00b6 Health Measures the state of physical, mental and social well-being in which disease and infirmity are absent. Achieving and maintaining health is an ongoing process, shaped by both the evolution of health care knowledge and practices as well as personal strategies and organized interventions for staying healthy. Diet : Measures how much does the food you eat follow a healthy diet. A healthy diet includes a variety of foods that provide the different nutrients required by your body to keep on running. Nutrients help build and strengthen bones, muscles, and tendons and also regulate body processes. Also remember that water consumption is essential. Exercise : Measures the amount of physical fitness. It strengthens muscles and improves the cardiovascular system. Sleep : Measures the quality of your rest. Sleep is an essential component to maintaining health. Ongoing sleep deprivation causes an increased risk for some chronic health problems. In addition, sleep deprivation correlates with both increased susceptibility to illness and slower recovery times from illness. Due to the role of sleep in regulating metabolism, insufficient sleep may also play a role in weight gain. Social Support : Measures the perception and actuality that one is cared for, has assistance available from other people, and that one is part of a supportive social network. Support can come from diverse sources, such as family, friends, pets, neighbors, coworkers, organizations, etc. There are four common functions of social support: Emotional support : Measures the offering of empathy, concern, affection, love, trust, acceptance, intimacy, encouragement, or caring. It's the warmth and nurturance provided by sources of social support. Providing emotional support can let the individual know that they are valued. Tangible support : Measures the provision of financial help, material goods, or services. Also called instrumental support, this form of social support encompasses the concrete, direct ways people assist others. Informational support : Measures the provision of advice, guidance, suggestions, or useful information to someone. Where this information has the potential to help others problem-solve. Companionship support : Measures the support that gives someone a sense of social belonging, the presence of companions to engage in shared social activities. It's also referred to as esteem support or appraisal support . Cleanliness : Measures both the abstract state of being clean and free from germs, dirt, trash, or waste, and the habit of achieving and maintaining that state. Hygiene : Measures the conditions and practices that help to maintain health and prevent the spread of diseases. It includes such personal habit choices as how frequently to take a shower or bath, wash hands, trim fingernails, and wash clothes. It also includes attention to keeping surfaces in the home and workplace clean and pathogen-free. Tidyness : Measures the condition or quality of having everything ordered and arranged in the right place. Physical attributes \u00b6 Physical Energy: Measures the amount of physical work that you can do before getting fatigued. Strength : Measures the exertion of force on physical objects. Dexterity: Measuring agility, balance, accuracy, speed, coordination and reflexes. Skills \u00b6 Skills are the abilities to perform an action with determined results within a given amount of time or energy. Skills are divided into domain-general and domain-specific skills. For example, in the domain of work, some general skills would include time management, teamwork and leadership, self-motivation and others, whereas domain-specific skills would be used only for a certain job. Skills can be categorized based on the level of expertise and motivation in different phases: Student : Get the basic knowledge required to start performing the skill. Apprentice : Use the basic knowledge following specified instructions. Specialist : Use the state of the art knowledge following specified instructions. Expert : Creatively use the knowledge to resolve problems defining new instructions. Craftsman : Create new knowledge, skills, products or services. We can use a skill tree to track the evolution and visualize the dependencies between them. We can model skill decay with pattern like the space repetition, so it's cheaper to relearn, and will increase of the percent you don't forget. States \u00b6 States are conditions derived by the combination of user attribute levels. They can be used to increase or decrease the rate of consumption/gain of other user attributes. For example if you are tired, you can loose energy more quickly. Emotional states. Mental states. Physical states. Health states. Traits \u00b6 Traits are habitual patterns of behavior, thought, and emotion that define our personality. They are stable over time, differ across individuals, are consistent over situations, and influence behavior. Traits are in contrast to states, which are more transitory dispositions. People at the MIT have gathered a list of different traits . We could use traits to let the user define themselves, using it as a modifier of their attributes in contrast of what they read as normal . For example, If the user thinks they are forgetful, they will have a penalty of -X in the Memory attribute. Task model \u00b6 A task is an activity performed to achieve a goal. The process of doing a task costs us time and consumption of user attributes. In exchange, we get other user attributes and the partial or total solving of the issue. The task attributes are: Time: Measures the amount of time required to perform the task. Estimated: Measures the amount of time we think we need to do the task. Real: Measures the real time it took us to perform the task. Effectiveness : Measures the capability of solving the issue. For example we could use the following scale: 5 : Fully solve the problem in a way that it doesn't happen again. 4 : Fully Solves part of the problem in a way that it doesn't happen again. 3 : Temporarily solves the problem for a long period of time. 2 : Temporarily solves part of the problem for a long period of time. 1 : Temporarily solves the problem for a short period of time. Attribute Cost/Gain: List of user attributes that gets consumed or obtained while doing the task. The total cost/gain will be calculated as the integral of these attributes over the time. Actions \u00b6 Actions are task templates, they are meant to reduce the user attribute management in the tasks. They are defined by group of words and gather a default value of task attributes like consumed/gained attributes, project, tags and associated skills. For example, shuffle dancing, identified by the words dance shuffle can have the following attributes: Priority: 2 Estimate: 1 Physical Energy: -5 Mental Energy: +2 Vitality: +4 Tranquility: +3 Pleasure: +4 Creativity: +3 Exercise: +3 Dexterity: +2 The following skills: Dancing: Apprentice Shuffle dancing: Apprentice And belong to the project dance . Then in the future you'll only need to write pydo add dance shuffle in the park . And all the attributes will be filled for you. Problem model \u00b6 Problems in the context of task management, are situations that need attention and to be solved. Problems are solved by behaviours and tasks. Problems can be grouped through projects or tags. The tasks and behaviours related to solving the problem will inherit them. They will have the following attributes: Value: Measures the degree of importance of the problem. Priority: Measures the need to be solved earlier compared to other problems. We can model the negative effect they produce over the user by globally subtracting user attribute points or by modifying the consumption rate of these attributes associating them to states. The amount of the effect can be a function of the overdue, priority and value. The decay will start decreasing the user attributes in polinomic or exponential rate. This way we could implement a soft recurrence, as we would have a repeating task without recurrence, that will get automatically priorized due to the issue overdue, but it won't appear in the overdue task list. They can have a recurrence of type recurring or repeating. Behaviour model \u00b6 Behaviours define the ways of acting. Tasks on the other hand define the actions to achieve a goal. So dancing three times a week would be a behaviour and dance in the park would be the task. Behaviours once implemented solve problems with a low consumption of self-control, mental load or physical and mental energy. Behaviours don't affect user attributes, but can spawn tasks that do. We'll aim to have a user friendly interface to keep on track of behaviours you want to adopt or remove. There will be a priorized list of behaviours that can be linked to projects and tags. There could be an interactive command line interface to answer at the start and/or end of the day to keep track of the evolution of them. Some behaviours can be linked to tasks, so once one is started, a popup is shown with the behaviours that you want to change, once the task is completed it will ask you if you've followed the behaviour or not. How does the system work \u00b6 The user will give each task the gained/consumed user attribute values either manually or through actions. While the tasks are active and at time of completion in case they weren't activated, the integral of those attributes will be added or removed from the global user attributes. Certain states will be defined to be activated when specific attribute levels are met. These states will change the consumption or gain of attributes while they are active. Based on the current user state, tasks will be or not recommended. At anytime it can assess the attributes of the remaining tasks for the day to see if its possible to achieve them, if they are not, recommend other tasks that can improve the attribute that is making it impossible or suggest to reschedule the least important tasks. Sleeping \u00b6 The first time the program is executed in the day, it could ask you how well and how much you've slept. Sleeping is one of the main sources of restoration. Based in the answer, we will receive a different states can be defined to affect the ratios of consumption/gain and total attribute levels. We could take the baseline of sleeping well (value: 3) for 8 hours as a state without buffs and a recovery of the 100% of the attributes. If we've slept 8 hours but really well (value: 5), we could get the state of rested which can give a temporal buff of more mental and physical energy. If instead we've badly (value: 2) slept 5 hours we'd recover only the 42% of the attributes the sleep resets (5*2/8*3) and get the tired state which increases the consumption of energy. Make the task tracking easier \u00b6 Tracking the active tasks is difficult and tedious, we need to make it user friendly. Some ideas to achieve it could be: Have a command that stops tracking all the tasks when the user blocks the screen, and opens a pop-up that allows with a keystroke to keep on working on the previous task. Keep track of the context switches, so if a task has been active for 2 hours, it will ask the user if they are still working on the task, and to get a rest. Track the focus on windows to extract what are you doing. Or at least that when we open a specific program, it will automatically start tracking the related task. The idea would be to implement it through aliases in the terminal. Tracking the unentered tasks can also be difficult. To make it easier we could: When there is a big period of untracked time, ask the user what did he do in that time. This can be done at the start or end of the day so as not to be too invasive. We could have a REPL interface to easily fill untracked times. With suggestions of common tasks completed in that time. Welcome and Goodbye reports \u00b6 We could have a welcome report that shows the tasks to be done in the day, with a timeline of the ones that have an due with hour and minute, and a priorized list of the others. We could have a goodbye report that asks your evaluation of the day, behaviours questions, and shows you tomorrow's tasks. Refactor the task model into problem solving model \u00b6 The idea is to drive your task priorization through the priorization of the problems you want to solve. The workflow would be to define a problem, and then the tasks and behaviours to solve it. The advantages of this model shift can be: The change in the priority of the problems, can affect a group of related tasks and behaviours thus helping in the planning. We can measure the cost of attributes of different solutions. For example if we had the problem of keeping the dishes clean, we could compare the task washing them manually and using the washing machine. Can be an help in auto assigning task attributes. And the following disadvantages: It adds a management overload, because we'll need to create two resources (problem and solving entity) instead of just one. The disadvantages can be solved with a user friendly REPL interface. Support tasks triggers \u00b6 Create triggers for task creation and completion to be able to: Support external hooks. Affect states. Affect behaviours. Program chained tasks. Support flexible due date for tasks \u00b6 Create a flexible due, where you specify the range of time around the due date where the task can be completed. Add a REPL interface \u00b6 Create a REPL interface to manage tasks in a way that: We see the entities that match a specified filter (i.e actionable tasks or problems). By default shows the state indicator, id and description. The state indicator will be one of the following: [ ] : Open entity. [x] : Done entity. [D] : Deleted entity. [B] : Blocked entity. With j and k you are able to navigate between them, zo and zc will be used to show/hide the entity attributes and children. << and >> will make a task the sibling or child of the one above it. d will complete the task, D will delete it, o will reopen it. b will block it, then will ask the user for the reason. a will create a sibling task, s will create a subtask. e will launch an editor interface to change the entity attributes. Create a REPL interface to add a task: Will prompt for the description, once entered it will try to automatically fill up the rest of attributes through actions or the related problem. Will show the generated attributes. And ask the user which attributes they want to edit. Acting differently on the keyboard events: enter : Create the task as is. t : launch the tag edition REPL interface: a : Ask the user for the tags to introduce, with fuzzy auto suggestion and auto completion. If the tag doesn't exist suggest similar existing tags, if none exist or the user doesn't want them, ask if they are sure to add a new tag. j and k : Navigate over the existing tags. d : Delete the selected tag. p : Launch the project edition REPL interface like the tag REPL interface above. Define bindings for the rest of the attributes, perform input validation afterwards. Monica support \u00b6 Connect pydo to Monica with the idea of linking Monica activities and phone calls with pydo tasks. Context support \u00b6 Create a way to be able to define which entities belong to a context or another like work or personal , and once active it will only show the entities of that context.","title":"Future Features"},{"location":"future_features/#the-game-of-life","text":"The goal is to measure the user state to suggest which kind of task are more suitable, raise alerts when the user reaches certain mental or physical states or give insights on the evolution of the user attributes.","title":"The game of life"},{"location":"future_features/#domain-model","text":"","title":"Domain Model"},{"location":"future_features/#user-model","text":"We could model the state of a human with the following attributes groups: Mental attributes. Health attributes. Physical attributes. Skills. Traits. I've still not figured out how to vary the total attribute values over the time.","title":"User model"},{"location":"future_features/#mental-attributes","text":"Mental Energy: Measures the amount of mental work that you can do before getting fatigued. Vitality: Measures your life force of wanting to do things. For example, for me, dancing or doing work out is a task that increases my vitality, while staying in the couch for 5 hours watching tv shows kills my vitality. Tranquility : Measures the state of being calm, serene, and worry-free. As a side effect it measures the levels of stress and anxiety. Mental load : Measure of the invisible labor involved in managing yourself, a household and your closed ones, which typically falls on women's shoulders. Also sometimes referred to as worry work or cognitive labor , the mental load is about not the physical tasks but rather the overseeing of those tasks. It's being the one in charge of having the never-ending list of to-do items constantly running in your head, remembering what needs to get done and when, delegating tasks to others, and making sure they actually get done. One study describes it as the responsibility of anticipating needs, identifying options for filling them, making decisions, and monitoring progress. Pleasure : Measures the broad class of mental states that we experience as positive, enjoyable, or worth seeking. It includes more specific states such as happiness, entertainment, enjoyment, ecstasy and euphoria. Intelligence : Measures the capacity for logic, understanding, self-awareness, learning, emotional knowledge, reasoning, planning, creativity, critical thinking, and problem-solving. More generally, it's the ability to perceive or infer information, and to keep it as knowledge to be applied towards adaptive behaviors within an environment or context. Logic : Measures the systematic study of valid rules of inference, i.e. the relations that lead to the acceptance of one proposition (the conclusion) on the basis of a set of other propositions (premises). More broadly, logic is the analysis and appraisal of arguments. Understanding : Measures the psychological process related to an abstract or physical object, such as a person, situation, or message whereby one is able to think about it and use concepts to deal adequately with that object. Understanding is a relation between the knower and an object of understanding. Understanding implies abilities and dispositions in relation to an object of knowledge that are enough to support intelligent behavior. Self-awareness : Measures the experience of one's own personality or individuality. While consciousness is being aware of one's environment and body and lifestyle, self-awareness is the recognition of that awareness. Self-awareness is how an individual consciously knows and understands their own character, feelings, motives, and desires. Learning : Measures the process of acquiring new understanding, knowledge, behaviors, skills, values, attitudes, and preferences. Emotional Intelligence : Measures the ability of individuals to recognize their own emotions and those of others, discern between different feelings and label them appropriately, use emotional information to guide thinking and behavior, and manage and/or adjust emotions to adapt to environments or achieve one's goals. Reasoning : Measures the capacity of consciously making sense of things, applying logic, and adapting or justifying practices, institutions, and beliefs based on new or existing information. It's associated with such characteristically human activities as philosophy, science, language, mathematics, and art. Reason is sometimes referred to as rationality. Planning : Measures the process of thinking about the activities required to achieve a desired goal. It involves the creation and maintenance of a plan, such as psychological aspects that require conceptual skills. Creativity : Measures the ability to create something new and somehow valuable. The created item may be intangible (such as an idea, a scientific theory, a musical composition, or a joke) or a physical object (such as an invention, a printed literary work, or a painting). Critical Thinking : Measures the analysis of facts to form a judgment. It's the rational, skeptical, unbiased analysis, or evaluation of facts. Critical thinking is self-directed, self-disciplined, self-monitored, and self-corrective thinking. It presupposes assent to rigorous standards of excellence and mindful command of their use. It entails effective communication and problem-solving abilities as well as a commitment to overcome native egocentrism and sociocentrism. Problem Solving : Measure the ability to use generic or ad hoc methods in an orderly manner to find solutions to problems. Memory : Measures the faculty of the brain to encode, store and retrieve over the time data or information. Self-control : Measures the ability to regulate one's emotions, thoughts, and behavior in the face of temptations and impulses. As an executive function, self-control is a cognitive process that is necessary for regulating one's behavior in order to achieve specific goals. Self-regulation, whether emotional or behavioral, is a limited resource which functions like energy. In the short term, overuse of self-control will lead to depletion. In the long term, the use of self-control can strengthen and improve over time. Social interaction : Measures the amount of relationship you can endure with other human beings. Wisdom : Measures the ability to think and act using knowledge, experience, understanding, common sense and insight. It's associated with attributes such as unbiased judgment, compassion, experiential self-knowledge, self-transcendence and non-attachment, and virtues such as ethics and benevolence. Charisma : Measures the force of personality, persuasiveness and leadership.","title":"Mental attributes"},{"location":"future_features/#health-attributes","text":"Health Measures the state of physical, mental and social well-being in which disease and infirmity are absent. Achieving and maintaining health is an ongoing process, shaped by both the evolution of health care knowledge and practices as well as personal strategies and organized interventions for staying healthy. Diet : Measures how much does the food you eat follow a healthy diet. A healthy diet includes a variety of foods that provide the different nutrients required by your body to keep on running. Nutrients help build and strengthen bones, muscles, and tendons and also regulate body processes. Also remember that water consumption is essential. Exercise : Measures the amount of physical fitness. It strengthens muscles and improves the cardiovascular system. Sleep : Measures the quality of your rest. Sleep is an essential component to maintaining health. Ongoing sleep deprivation causes an increased risk for some chronic health problems. In addition, sleep deprivation correlates with both increased susceptibility to illness and slower recovery times from illness. Due to the role of sleep in regulating metabolism, insufficient sleep may also play a role in weight gain. Social Support : Measures the perception and actuality that one is cared for, has assistance available from other people, and that one is part of a supportive social network. Support can come from diverse sources, such as family, friends, pets, neighbors, coworkers, organizations, etc. There are four common functions of social support: Emotional support : Measures the offering of empathy, concern, affection, love, trust, acceptance, intimacy, encouragement, or caring. It's the warmth and nurturance provided by sources of social support. Providing emotional support can let the individual know that they are valued. Tangible support : Measures the provision of financial help, material goods, or services. Also called instrumental support, this form of social support encompasses the concrete, direct ways people assist others. Informational support : Measures the provision of advice, guidance, suggestions, or useful information to someone. Where this information has the potential to help others problem-solve. Companionship support : Measures the support that gives someone a sense of social belonging, the presence of companions to engage in shared social activities. It's also referred to as esteem support or appraisal support . Cleanliness : Measures both the abstract state of being clean and free from germs, dirt, trash, or waste, and the habit of achieving and maintaining that state. Hygiene : Measures the conditions and practices that help to maintain health and prevent the spread of diseases. It includes such personal habit choices as how frequently to take a shower or bath, wash hands, trim fingernails, and wash clothes. It also includes attention to keeping surfaces in the home and workplace clean and pathogen-free. Tidyness : Measures the condition or quality of having everything ordered and arranged in the right place.","title":"Health attributes"},{"location":"future_features/#physical-attributes","text":"Physical Energy: Measures the amount of physical work that you can do before getting fatigued. Strength : Measures the exertion of force on physical objects. Dexterity: Measuring agility, balance, accuracy, speed, coordination and reflexes.","title":"Physical attributes"},{"location":"future_features/#skills","text":"Skills are the abilities to perform an action with determined results within a given amount of time or energy. Skills are divided into domain-general and domain-specific skills. For example, in the domain of work, some general skills would include time management, teamwork and leadership, self-motivation and others, whereas domain-specific skills would be used only for a certain job. Skills can be categorized based on the level of expertise and motivation in different phases: Student : Get the basic knowledge required to start performing the skill. Apprentice : Use the basic knowledge following specified instructions. Specialist : Use the state of the art knowledge following specified instructions. Expert : Creatively use the knowledge to resolve problems defining new instructions. Craftsman : Create new knowledge, skills, products or services. We can use a skill tree to track the evolution and visualize the dependencies between them. We can model skill decay with pattern like the space repetition, so it's cheaper to relearn, and will increase of the percent you don't forget.","title":"Skills"},{"location":"future_features/#states","text":"States are conditions derived by the combination of user attribute levels. They can be used to increase or decrease the rate of consumption/gain of other user attributes. For example if you are tired, you can loose energy more quickly. Emotional states. Mental states. Physical states. Health states.","title":"States"},{"location":"future_features/#traits","text":"Traits are habitual patterns of behavior, thought, and emotion that define our personality. They are stable over time, differ across individuals, are consistent over situations, and influence behavior. Traits are in contrast to states, which are more transitory dispositions. People at the MIT have gathered a list of different traits . We could use traits to let the user define themselves, using it as a modifier of their attributes in contrast of what they read as normal . For example, If the user thinks they are forgetful, they will have a penalty of -X in the Memory attribute.","title":"Traits"},{"location":"future_features/#task-model","text":"A task is an activity performed to achieve a goal. The process of doing a task costs us time and consumption of user attributes. In exchange, we get other user attributes and the partial or total solving of the issue. The task attributes are: Time: Measures the amount of time required to perform the task. Estimated: Measures the amount of time we think we need to do the task. Real: Measures the real time it took us to perform the task. Effectiveness : Measures the capability of solving the issue. For example we could use the following scale: 5 : Fully solve the problem in a way that it doesn't happen again. 4 : Fully Solves part of the problem in a way that it doesn't happen again. 3 : Temporarily solves the problem for a long period of time. 2 : Temporarily solves part of the problem for a long period of time. 1 : Temporarily solves the problem for a short period of time. Attribute Cost/Gain: List of user attributes that gets consumed or obtained while doing the task. The total cost/gain will be calculated as the integral of these attributes over the time.","title":"Task model"},{"location":"future_features/#actions","text":"Actions are task templates, they are meant to reduce the user attribute management in the tasks. They are defined by group of words and gather a default value of task attributes like consumed/gained attributes, project, tags and associated skills. For example, shuffle dancing, identified by the words dance shuffle can have the following attributes: Priority: 2 Estimate: 1 Physical Energy: -5 Mental Energy: +2 Vitality: +4 Tranquility: +3 Pleasure: +4 Creativity: +3 Exercise: +3 Dexterity: +2 The following skills: Dancing: Apprentice Shuffle dancing: Apprentice And belong to the project dance . Then in the future you'll only need to write pydo add dance shuffle in the park . And all the attributes will be filled for you.","title":"Actions"},{"location":"future_features/#problem-model","text":"Problems in the context of task management, are situations that need attention and to be solved. Problems are solved by behaviours and tasks. Problems can be grouped through projects or tags. The tasks and behaviours related to solving the problem will inherit them. They will have the following attributes: Value: Measures the degree of importance of the problem. Priority: Measures the need to be solved earlier compared to other problems. We can model the negative effect they produce over the user by globally subtracting user attribute points or by modifying the consumption rate of these attributes associating them to states. The amount of the effect can be a function of the overdue, priority and value. The decay will start decreasing the user attributes in polinomic or exponential rate. This way we could implement a soft recurrence, as we would have a repeating task without recurrence, that will get automatically priorized due to the issue overdue, but it won't appear in the overdue task list. They can have a recurrence of type recurring or repeating.","title":"Problem model"},{"location":"future_features/#behaviour-model","text":"Behaviours define the ways of acting. Tasks on the other hand define the actions to achieve a goal. So dancing three times a week would be a behaviour and dance in the park would be the task. Behaviours once implemented solve problems with a low consumption of self-control, mental load or physical and mental energy. Behaviours don't affect user attributes, but can spawn tasks that do. We'll aim to have a user friendly interface to keep on track of behaviours you want to adopt or remove. There will be a priorized list of behaviours that can be linked to projects and tags. There could be an interactive command line interface to answer at the start and/or end of the day to keep track of the evolution of them. Some behaviours can be linked to tasks, so once one is started, a popup is shown with the behaviours that you want to change, once the task is completed it will ask you if you've followed the behaviour or not.","title":"Behaviour model"},{"location":"future_features/#how-does-the-system-work","text":"The user will give each task the gained/consumed user attribute values either manually or through actions. While the tasks are active and at time of completion in case they weren't activated, the integral of those attributes will be added or removed from the global user attributes. Certain states will be defined to be activated when specific attribute levels are met. These states will change the consumption or gain of attributes while they are active. Based on the current user state, tasks will be or not recommended. At anytime it can assess the attributes of the remaining tasks for the day to see if its possible to achieve them, if they are not, recommend other tasks that can improve the attribute that is making it impossible or suggest to reschedule the least important tasks.","title":"How does the system work"},{"location":"future_features/#sleeping","text":"The first time the program is executed in the day, it could ask you how well and how much you've slept. Sleeping is one of the main sources of restoration. Based in the answer, we will receive a different states can be defined to affect the ratios of consumption/gain and total attribute levels. We could take the baseline of sleeping well (value: 3) for 8 hours as a state without buffs and a recovery of the 100% of the attributes. If we've slept 8 hours but really well (value: 5), we could get the state of rested which can give a temporal buff of more mental and physical energy. If instead we've badly (value: 2) slept 5 hours we'd recover only the 42% of the attributes the sleep resets (5*2/8*3) and get the tired state which increases the consumption of energy.","title":"Sleeping"},{"location":"future_features/#make-the-task-tracking-easier","text":"Tracking the active tasks is difficult and tedious, we need to make it user friendly. Some ideas to achieve it could be: Have a command that stops tracking all the tasks when the user blocks the screen, and opens a pop-up that allows with a keystroke to keep on working on the previous task. Keep track of the context switches, so if a task has been active for 2 hours, it will ask the user if they are still working on the task, and to get a rest. Track the focus on windows to extract what are you doing. Or at least that when we open a specific program, it will automatically start tracking the related task. The idea would be to implement it through aliases in the terminal. Tracking the unentered tasks can also be difficult. To make it easier we could: When there is a big period of untracked time, ask the user what did he do in that time. This can be done at the start or end of the day so as not to be too invasive. We could have a REPL interface to easily fill untracked times. With suggestions of common tasks completed in that time.","title":"Make the task tracking easier"},{"location":"future_features/#welcome-and-goodbye-reports","text":"We could have a welcome report that shows the tasks to be done in the day, with a timeline of the ones that have an due with hour and minute, and a priorized list of the others. We could have a goodbye report that asks your evaluation of the day, behaviours questions, and shows you tomorrow's tasks.","title":"Welcome and Goodbye reports"},{"location":"future_features/#refactor-the-task-model-into-problem-solving-model","text":"The idea is to drive your task priorization through the priorization of the problems you want to solve. The workflow would be to define a problem, and then the tasks and behaviours to solve it. The advantages of this model shift can be: The change in the priority of the problems, can affect a group of related tasks and behaviours thus helping in the planning. We can measure the cost of attributes of different solutions. For example if we had the problem of keeping the dishes clean, we could compare the task washing them manually and using the washing machine. Can be an help in auto assigning task attributes. And the following disadvantages: It adds a management overload, because we'll need to create two resources (problem and solving entity) instead of just one. The disadvantages can be solved with a user friendly REPL interface.","title":"Refactor the task model into problem solving model"},{"location":"future_features/#support-tasks-triggers","text":"Create triggers for task creation and completion to be able to: Support external hooks. Affect states. Affect behaviours. Program chained tasks.","title":"Support tasks triggers"},{"location":"future_features/#support-flexible-due-date-for-tasks","text":"Create a flexible due, where you specify the range of time around the due date where the task can be completed.","title":"Support flexible due date for tasks"},{"location":"future_features/#add-a-repl-interface","text":"Create a REPL interface to manage tasks in a way that: We see the entities that match a specified filter (i.e actionable tasks or problems). By default shows the state indicator, id and description. The state indicator will be one of the following: [ ] : Open entity. [x] : Done entity. [D] : Deleted entity. [B] : Blocked entity. With j and k you are able to navigate between them, zo and zc will be used to show/hide the entity attributes and children. << and >> will make a task the sibling or child of the one above it. d will complete the task, D will delete it, o will reopen it. b will block it, then will ask the user for the reason. a will create a sibling task, s will create a subtask. e will launch an editor interface to change the entity attributes. Create a REPL interface to add a task: Will prompt for the description, once entered it will try to automatically fill up the rest of attributes through actions or the related problem. Will show the generated attributes. And ask the user which attributes they want to edit. Acting differently on the keyboard events: enter : Create the task as is. t : launch the tag edition REPL interface: a : Ask the user for the tags to introduce, with fuzzy auto suggestion and auto completion. If the tag doesn't exist suggest similar existing tags, if none exist or the user doesn't want them, ask if they are sure to add a new tag. j and k : Navigate over the existing tags. d : Delete the selected tag. p : Launch the project edition REPL interface like the tag REPL interface above. Define bindings for the rest of the attributes, perform input validation afterwards.","title":"Add a REPL interface"},{"location":"future_features/#monica-support","text":"Connect pydo to Monica with the idea of linking Monica activities and phone calls with pydo tasks.","title":"Monica support"},{"location":"future_features/#context-support","text":"Create a way to be able to define which entities belong to a context or another like work or personal , and once active it will only show the entities of that context.","title":"Context support"},{"location":"objective_value/","text":"The value optional task attribute registers how much you feel this task is going to help you achieve a specific goal. It can be associated with Scrum business value . Business value is an horrendous capitalist term with a lot of implications, therefore we've shorten it to value . If you've categorized your tasks in projects , each one probably has one or several main objectives. If your tasks have this property, it can help you priorize which ones need to be done first, or measure the difference in value between sprints. To set the value of a task use the vl or value keyword: $: pydo add Task with high value value:5 [+] Added task 4: Task with high value As with the priority , I use a range of values from 0 (it doesn't get me closer to the objective at all) to 5 (it's a critical advance towards the goal) but the parameter allows any integer.","title":"Value"},{"location":"priority/","text":"The priority optional task attribute registers how urgent a task is. The parameter allows any integer, but I use from 0 (really low priority) to 5 (really high priority), being 3 the standard medium priority. To set the priority of a task use the pri or priority keyword: $: pydo add Task with highest priority pri:5 [ + ] Added task 2 : Task with highest priority Right now we only use the priority for filtering or visualization purposes. But we plan to support reports that sort the tasks by their urgency . The priority will be one of the main factors to take into account.","title":"Priority"},{"location":"recurrence/","text":"Recurrence is used to create periodical tasks, such as paying the rent or mowing the lawn. There are two types of recurrence: Recurring : Task which needs to be done every specified period of time, like day, week, etc. It doesn't matter when you complete the task, the next one will be created based on the original due date. Repeating : When this task gets completed or deleted, a duplicate will be created with the specified time offset from the closing date. I.e. subsequent tasks get delayed (e.g. mowing the lawn). pydo implements recurrence with the creation of two kind of tasks: parent and children. The first one holds the template for the second. Each time a child is completed or deleted, the parent attributes are copied and the due date is set according to the recurrence type. pydo will only maintain one children per parent, so it won't create new tasks until the existent is either completed or deleted. Furthermore, it will create only the next actionable task. So if from the last completed children you've missed 3 tasks, those won't be created. Create a recurring or repeating task. \u00b6 To create a recurrent or repeating task, the recurrence time must be set under the rec or rep attribute. That attribute must match the pytho date format. $: pydo add Pay the rent due:2021-11-01 rec:1mo [ + ] Added recurring task 0 : Pay the rent [ + ] Added first child task with id 1 $: pydo add Mow the lawn due:today rep:20d [ + ] Added repeating task 1 : Mow the lawn [ + ] Added first child task with id 2 Once they are created, the children will show in the open report, but not the parent. $: pydo \u2577 \u2577 \u2577 ID \u2502 Description \u2502 Due \u2502 Parent \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 1 \u2502 Pay the rent \u2502 2021 -11-01 00 :00 \u2502 0 2 \u2502 Mow the lawn \u2502 2021 -10-07 13 :38 \u2502 1 \u2575 \u2575 \u2575 The recurrent and repeating parents can be seen with the recurring report. $: pydo recurring \u2577 \u2577 \u2577 \u2577 ID \u2502 Description \u2502 Recur \u2502 RecurType \u2502 Due \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 0 \u2502 Pay the rent \u2502 1mo \u2502 Recurring \u2502 2021 -11-01 00 :00 1 \u2502 Mow the lawn \u2502 20d \u2502 Repeating \u2502 2021 -10-07 13 :38 \u2575 \u2575 \u2575 \u2575 Completing or deleting a repeating task \u00b6 If you complete or delete the children of a recurrent or repeating task, the next child will be spawned. But if you wish to delete or complete the parent so no further children gets created, you can do either by calling do or rm with the parent task id, or with the --parent flag with the child id. The advantage of the second method is that you don't need to know the parent id, and it will close both parent and children. $: pydo rm --parent 1 [ + ] Closed child task 1 : Pay the rent with state deleted [ + ] Closed parent task 0 : Pay the rent with state deleted $: pydo \u2577 \u2577 \u2577 ID \u2502 Description \u2502 Due \u2502 Parent \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 2 \u2502 Mow the lawn \u2502 2021 -10-07 13 :43 \u2502 1 \u2575 \u2575 \u2575 Modifying a recurring task \u00b6 If changes are made in a child task, those changes wont be propagated to the following children, if you want to make changes permanent, you need to change the parent either using the parent task id or using mod --parent with the children id. Freeze a parent task \u00b6 If you need to temporary pause the creation of new children you can freeze the parent task either with it's id or with freeze --parent using the children id. Frozen tasks will appear in the frozen report. To resume the children creation use the thaw command. $: pydo freeze 2 --parent [+] Frozen recurrent task 1: Mow the lawn and deleted it's last child 2 $: pydo thaw 1 [+] Thawed task 1: Mow the lawn, and created it's next child task with id 3","title":"Recurrence"},{"location":"recurrence/#create-a-recurring-or-repeating-task","text":"To create a recurrent or repeating task, the recurrence time must be set under the rec or rep attribute. That attribute must match the pytho date format. $: pydo add Pay the rent due:2021-11-01 rec:1mo [ + ] Added recurring task 0 : Pay the rent [ + ] Added first child task with id 1 $: pydo add Mow the lawn due:today rep:20d [ + ] Added repeating task 1 : Mow the lawn [ + ] Added first child task with id 2 Once they are created, the children will show in the open report, but not the parent. $: pydo \u2577 \u2577 \u2577 ID \u2502 Description \u2502 Due \u2502 Parent \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 1 \u2502 Pay the rent \u2502 2021 -11-01 00 :00 \u2502 0 2 \u2502 Mow the lawn \u2502 2021 -10-07 13 :38 \u2502 1 \u2575 \u2575 \u2575 The recurrent and repeating parents can be seen with the recurring report. $: pydo recurring \u2577 \u2577 \u2577 \u2577 ID \u2502 Description \u2502 Recur \u2502 RecurType \u2502 Due \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 0 \u2502 Pay the rent \u2502 1mo \u2502 Recurring \u2502 2021 -11-01 00 :00 1 \u2502 Mow the lawn \u2502 20d \u2502 Repeating \u2502 2021 -10-07 13 :38 \u2575 \u2575 \u2575 \u2575","title":"Create a recurring or repeating task."},{"location":"recurrence/#completing-or-deleting-a-repeating-task","text":"If you complete or delete the children of a recurrent or repeating task, the next child will be spawned. But if you wish to delete or complete the parent so no further children gets created, you can do either by calling do or rm with the parent task id, or with the --parent flag with the child id. The advantage of the second method is that you don't need to know the parent id, and it will close both parent and children. $: pydo rm --parent 1 [ + ] Closed child task 1 : Pay the rent with state deleted [ + ] Closed parent task 0 : Pay the rent with state deleted $: pydo \u2577 \u2577 \u2577 ID \u2502 Description \u2502 Due \u2502 Parent \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 2 \u2502 Mow the lawn \u2502 2021 -10-07 13 :43 \u2502 1 \u2575 \u2575 \u2575","title":"Completing or deleting a repeating task"},{"location":"recurrence/#modifying-a-recurring-task","text":"If changes are made in a child task, those changes wont be propagated to the following children, if you want to make changes permanent, you need to change the parent either using the parent task id or using mod --parent with the children id.","title":"Modifying a recurring task"},{"location":"recurrence/#freeze-a-parent-task","text":"If you need to temporary pause the creation of new children you can freeze the parent task either with it's id or with freeze --parent using the children id. Frozen tasks will appear in the frozen report. To resume the children creation use the thaw command. $: pydo freeze 2 --parent [+] Frozen recurrent task 1: Mow the lawn and deleted it's last child 2 $: pydo thaw 1 [+] Thawed task 1: Mow the lawn, and created it's next child task with id 3","title":"Freeze a parent task"},{"location":"reference/","text":"::: pydo","title":"Reference"},{"location":"related/","text":"If pydo isn't your cup of tea, maybe one of the other free task managers fits the bill: Buku : Store and manage your bookmarks from the command line. CommitTasks : Combination between git commit and todo list. Eureka : CLI tool to input and store ideas without leaving the terminal. Ff : A distributed note taker and task manager. git-pending : Git plugin to list TODO, FIXME, TESTME, DOCME comments in a repository. Org mode : Notes and todo lists powered by an Emacs based plain-text system. Smos : Purely functional semantic tree-based editor (similar to [Org mode]). Taskbook : Tasks, boards & notes for the command-line habitat. Taskell : Command line Kanban board / task management. Taskwarrior : Command line task management. Tasklite : Command line tool built with Haskell and SQLite. Toodles : Project management from the TODO's in your codebase. Tracli : Command line app that tracks your time. Ultralist : Open source task management system for the command line. Unfog : A simple CLI task and time manager. Yokadi : Command line oriented, SQLite powered todo list. Eagle : Minimalistic todo app for command line.","title":"Related"},{"location":"reports/","text":"pydo comes with some configured reports, such as open , closed , recurring , overdue , frozen . Each of them accepts a task filter that let's you do more specific queries over the content shown by those reports. Even so, you may want to create your own reports, or change the existing ones. All report configuration is saved in the config file (by default at ~/.local/share/pydo/config.yaml ) under the key task_reports . Each of them has the following properties: report_name : It's the key that identifies the report. columns : Ordered list of task attributes to print. filter : Dictionary of task properties that narrow down the tasks you want to print. sort : Ordered list of criteria used to sort the tasks. To create a new report that shows the open tasks of the area health and priority 5 , sorted descending by priority, edit your config file as the next snippet: reports : task_reports : important_health : filter : active : true type : task area : health priority : 5 sort : - \"-priority\" columns : - id_ - description - area - priority - tags - due - parent_id","title":"Reports"},{"location":"sorting/","text":"pydo lets you sort the contents of any report with the sort: task filter. By default, the reports are sorted increasingly by the task id. $: pydo open \u2577 \u2577 ID \u2502 Description \u2502 Pri \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2578 0 \u2502 First task with medium priority \u2502 3 1 \u2502 Second task with medium priority \u2502 3 2 \u2502 Third task with low priority \u2502 1 \u2575 \u2575 If you want to sort the tasks increasingly by priority instead, you could use: $: pydo open sort:+priority \u2577 \u2577 ID \u2502 Description \u2502 Pri \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2578 2 \u2502 Third task with low priority \u2502 1 0 \u2502 First task with medium priority \u2502 3 1 \u2502 Second task with medium priority \u2502 3 \u2575 \u2575 To sort by more than one criteria, separate them by commas. For example, if you want to sort increasingly by priority and then decreasingly by id, use: $: pydo open sort:+priority,-id_ \u2577 \u2577 ID \u2502 Description \u2502 Pri \u257a\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2578 2 \u2502 Third task with low priority \u2502 1 1 \u2502 Second task with medium priority \u2502 3 0 \u2502 First task with medium priority \u2502 3 \u2575 \u2575 To sort by ID you need to use id_ instead of id .","title":"Sorting"},{"location":"tags/","text":"Tags are the other way of clustering your tasks, unlike areas , a task can have many tags. So adding tags is the way to cluster tasks that share an attribute. For example, you can use python for tasks related to developing programs with that language, or if you don't use willpower , light could be used to gather easily done tasks. To add a tag to a task, we use the +tag keyword. pydo add Fix pydo install process +python To see all the existing tags, use the tags report: $: pydo tags \u2577 Name \u2502 Open Tasks \u257a\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 None \u2502 4 python \u2502 1 To add a tag to an existing task or to remove one, use the mod command. pydo mod {{ task_filter }} +new_tag pydo mod {{ task_filter }} -existing_tag","title":"Tags"},{"location":"update/","text":"To update pydo , follow the next steps: pip3 install --upgrade git+git://github.com/lyz-code/pydo pydo install It will apply all the alembic SQL migration scripts and seed the new configuration parameters.","title":"Update"},{"location":"willpower/","text":"The willpower optional task attribute registers how much energy the execution of the task consumes. Understanding energy as physical or mental energy. For example, solving a complex programming problem, doing long boring tasks or running a marathon have high willpower value, meanwhile watering the plants, going for a walk or to the cinema have a low value. If your tasks have this property, it can help you determine the tasks to be done during the sprint and in what order so as not to burn yourself out. Or to analyze which tasks can be candidates for automation or habit building. To set the value of a task use the wp or willpower keyword: $: pydo add Add recurrence support to pydo willpower:4 [+] Added task 5: Add recurrence support to pydo As with the priority , I use a range of values from 0 to 5 but the parameter allows any integer.","title":"Willpower"},{"location":"adr/001-change-id-from-str-to-int/","text":"Status \u00b6 Accepted Context \u00b6 Older versions of pydo use fulid ids to define the entities as it's easy to create the short ids from them in order to present them to the user through the cli interface. To do it, at service level it creates the next id with the _create_next_id function. The current system adds a lot of complexity for the sake of identifying entities through the minimum amount of keystrokes chosen from a set of keys defined by the user. Newer versions of the repository-orm library manages automatically id increments if the id_ field is of type int . This allows the addition of entities without id, which will be very useful to create children task objects at model level instead of service level. I'm more and more convinced that the ideal everyday user interface is not a command line program, but an REPL interface. The first one is meant only for bulk operations, not for operations on one item. That means that being able to tell apart tasks using short ids has loosing importance as this idea evolves. Proposals \u00b6 Change the entities id_ type from str to Optional[int] , so pydo can delegate it's management to the repository. When using the command line, we can show the ids as numbers, or optionally do the translation from numbers to the user chosen keys. But we won't be as optimal as before, because currently the short ids are defined by the subset of open tasks, and we'll use all the tasks, so more keystrokes will be needed. But this is acceptable as most of the times you'll use the REPL interface to interact with individual tasks, and when bulk editing you'll use task filters instead of the ids. We can even envision how to effectively do bulk edits through the REPL. The REPL interface will not even show the ids, you'll move through the tasks by vim movement keys or by fuzzy searching. Decision \u00b6 Consequences \u00b6","title":"Status"},{"location":"adr/001-change-id-from-str-to-int/#status","text":"Accepted","title":"Status"},{"location":"adr/001-change-id-from-str-to-int/#context","text":"Older versions of pydo use fulid ids to define the entities as it's easy to create the short ids from them in order to present them to the user through the cli interface. To do it, at service level it creates the next id with the _create_next_id function. The current system adds a lot of complexity for the sake of identifying entities through the minimum amount of keystrokes chosen from a set of keys defined by the user. Newer versions of the repository-orm library manages automatically id increments if the id_ field is of type int . This allows the addition of entities without id, which will be very useful to create children task objects at model level instead of service level. I'm more and more convinced that the ideal everyday user interface is not a command line program, but an REPL interface. The first one is meant only for bulk operations, not for operations on one item. That means that being able to tell apart tasks using short ids has loosing importance as this idea evolves.","title":"Context"},{"location":"adr/001-change-id-from-str-to-int/#proposals","text":"Change the entities id_ type from str to Optional[int] , so pydo can delegate it's management to the repository. When using the command line, we can show the ids as numbers, or optionally do the translation from numbers to the user chosen keys. But we won't be as optimal as before, because currently the short ids are defined by the subset of open tasks, and we'll use all the tasks, so more keystrokes will be needed. But this is acceptable as most of the times you'll use the REPL interface to interact with individual tasks, and when bulk editing you'll use task filters instead of the ids. We can even envision how to effectively do bulk edits through the REPL. The REPL interface will not even show the ids, you'll move through the tasks by vim movement keys or by fuzzy searching.","title":"Proposals"},{"location":"adr/001-change-id-from-str-to-int/#decision","text":"","title":"Decision"},{"location":"adr/001-change-id-from-str-to-int/#consequences","text":"","title":"Consequences"},{"location":"adr/0xx-agenda/","text":"Status \u00b6 Draft Context \u00b6 We want in a user friendly way to: See the tasks that need to be done today, and in this week Plan the day, which task needs to be done when Get notifications when it's time to do a task (for example attend a meeting) Graphical visualization on how much time is left for the active task Proposals \u00b6 We can create two TUI interfaces: Landing page: Where the relevant information about the state of the tasks is shown Day planning: Where the user can organize the day. Landing page \u00b6 The user will have the choice to activate or deactivate any of the next sections. Day's plan section \u00b6 Shows the day's plan, something like: 07:00 - 08:00 Breakfast 07:30 Review Anki 08:00 - 13:00 Work 08:00 Work on task 1 11:00 - 11:30 Meeting 13:00 - 14:00 Lunch Where: Active elements are in green. An element is activated if their start planned date < actual date and they are not closed. Overdue elements are in red. An element is overdue if their end planned date > actual date and they are not closed. Closed elements are in grey. If a task doesn't have an end planned date, it means that it can be done whenever in the day since the start planned date. If a task has the notify attribute set, an alert will be raised when the start date arrives, so that it's actionable, it'll also raise another alert when it becomes overdue. If a task has the start_reminder or end_reminder attributes set, a notification will be shown that amount of time before the start or end date. By default the cursor will be at the first active task. Controls \u00b6 The user will be able to interact with the TUI through: jk : to move between the elements d : Toggle element state from done to todo. D : Delete the element h : Toggle the hiding of completed elements m : Toggle the moving mode. Moving mode will move the highlighted element with jk . enter : Enter the Task TUI e : Edit the highlighted element description. a : Add an element through the task creation TUI Close future task section \u00b6 Shows the tasks that have a due date in the next X days: ----------- 2021-09-25 -------------- 11:00 Meeting Task 2 ----------- 2021-09-26 -------------- Task 3 Controls \u00b6 The user will be able to interact with the TUI through: jk : to move between the elements d : Toggle element state from done to todo. D : Delete the element m : Toggle the moving mode. Moving mode will move the highlighted element with jk . enter : Enter the Task TUI e : Edit the highlighted element description. a : Add an element through the task creation TUI Notifications section \u00b6 Shows relevant events related to the tasks state: A task has become overdue A task has become actionable Overdue: Task 1 Actionable: Task 2 Controls \u00b6 The user will be able to interact with the TUI through: jk : to move between the elements d : Mark the element as seen enter : Enter the Task TUI Next tasks section \u00b6 An ordered list of the tasks that should be actioned upon next. Returned by the Next report. Controls \u00b6 The user will be able to interact with the TUI through: jk : to move between the elements d : Toggle element state from done to todo. D : Toggle element state from deleted to todo. m : Toggle the moving mode. Moving mode will move the highlighted element with jk . enter : Enter the Task TUI e : Edit the highlighted element description. a : Add an element through the task creation TUI Task section \u00b6 Shows the active Task TUI. Defined in this adr . Day planning \u00b6 The tasks for the day need to have a plan date. Decision \u00b6 Consequences \u00b6","title":"Status"},{"location":"adr/0xx-agenda/#status","text":"Draft","title":"Status"},{"location":"adr/0xx-agenda/#context","text":"We want in a user friendly way to: See the tasks that need to be done today, and in this week Plan the day, which task needs to be done when Get notifications when it's time to do a task (for example attend a meeting) Graphical visualization on how much time is left for the active task","title":"Context"},{"location":"adr/0xx-agenda/#proposals","text":"We can create two TUI interfaces: Landing page: Where the relevant information about the state of the tasks is shown Day planning: Where the user can organize the day.","title":"Proposals"},{"location":"adr/0xx-agenda/#landing-page","text":"The user will have the choice to activate or deactivate any of the next sections.","title":"Landing page"},{"location":"adr/0xx-agenda/#days-plan-section","text":"Shows the day's plan, something like: 07:00 - 08:00 Breakfast 07:30 Review Anki 08:00 - 13:00 Work 08:00 Work on task 1 11:00 - 11:30 Meeting 13:00 - 14:00 Lunch Where: Active elements are in green. An element is activated if their start planned date < actual date and they are not closed. Overdue elements are in red. An element is overdue if their end planned date > actual date and they are not closed. Closed elements are in grey. If a task doesn't have an end planned date, it means that it can be done whenever in the day since the start planned date. If a task has the notify attribute set, an alert will be raised when the start date arrives, so that it's actionable, it'll also raise another alert when it becomes overdue. If a task has the start_reminder or end_reminder attributes set, a notification will be shown that amount of time before the start or end date. By default the cursor will be at the first active task.","title":"Day's plan section"},{"location":"adr/0xx-agenda/#controls","text":"The user will be able to interact with the TUI through: jk : to move between the elements d : Toggle element state from done to todo. D : Delete the element h : Toggle the hiding of completed elements m : Toggle the moving mode. Moving mode will move the highlighted element with jk . enter : Enter the Task TUI e : Edit the highlighted element description. a : Add an element through the task creation TUI","title":"Controls"},{"location":"adr/0xx-agenda/#close-future-task-section","text":"Shows the tasks that have a due date in the next X days: ----------- 2021-09-25 -------------- 11:00 Meeting Task 2 ----------- 2021-09-26 -------------- Task 3","title":"Close future task section"},{"location":"adr/0xx-agenda/#controls_1","text":"The user will be able to interact with the TUI through: jk : to move between the elements d : Toggle element state from done to todo. D : Delete the element m : Toggle the moving mode. Moving mode will move the highlighted element with jk . enter : Enter the Task TUI e : Edit the highlighted element description. a : Add an element through the task creation TUI","title":"Controls"},{"location":"adr/0xx-agenda/#notifications-section","text":"Shows relevant events related to the tasks state: A task has become overdue A task has become actionable Overdue: Task 1 Actionable: Task 2","title":"Notifications section"},{"location":"adr/0xx-agenda/#controls_2","text":"The user will be able to interact with the TUI through: jk : to move between the elements d : Mark the element as seen enter : Enter the Task TUI","title":"Controls"},{"location":"adr/0xx-agenda/#next-tasks-section","text":"An ordered list of the tasks that should be actioned upon next. Returned by the Next report.","title":"Next tasks section"},{"location":"adr/0xx-agenda/#controls_3","text":"The user will be able to interact with the TUI through: jk : to move between the elements d : Toggle element state from done to todo. D : Toggle element state from deleted to todo. m : Toggle the moving mode. Moving mode will move the highlighted element with jk . enter : Enter the Task TUI e : Edit the highlighted element description. a : Add an element through the task creation TUI","title":"Controls"},{"location":"adr/0xx-agenda/#task-section","text":"Shows the active Task TUI. Defined in this adr .","title":"Task section"},{"location":"adr/0xx-agenda/#day-planning","text":"The tasks for the day need to have a plan date.","title":"Day planning"},{"location":"adr/0xx-agenda/#decision","text":"","title":"Decision"},{"location":"adr/0xx-agenda/#consequences","text":"","title":"Consequences"},{"location":"adr/0xx-subtasks-and-steps/","text":"Status \u00b6 Draft Context \u00b6 We need to define how are we going to split long tasks into smaller actionable steps in an user friendly way. Proposals \u00b6 There are two use cases: Big tasks that need to be subdivided in smaller tasks to enter a sprint Small enough tasks to enter the sprint, where the user wants to define the small steps required to complete it. Creating a task requires time to fill up it's attributes: assign an area, tags, priority, description... It also adds time to the overall management of all the tasks. This time investment makes sense only for the first case, the small steps often change and don't have the size to be managed with the rest of the tasks. Task division \u00b6 This idea supports the plan to subdivide a task at two levels: subtasks and steps. Subtasks will be Task entities so that we can do infinite levels of subtask nesting. To achieve this we'll need to change the Task model to add an attribute parent_id that allows us to relate a task with its subtasks. Steps will be a new simpler entity Step with only parent_id , created , closed , state and description , so that it will be easier to create, potentially only the description will be filled by the user, and as it follows the same structure it will be easy to promote to Task if needed. Step s don't have identity by themselves, they are tightly coupled with a task, that's why they could be saved under the steps attribute of the Task . Until repository-orm supports nested objects, we'll only be able to use the TinyDB and Fake repositories. The benefit from being a task attribute is that recurrent tasks will inherit them automatically. In the first iteration to simplify the logic: Steps and subtasks will be mutually exclusive. Recurrent tasks won't support subtasks, as the children breed won't be trivial. Paths \u00b6 Sometimes the task divisions (steps or subtasks) are related between each other, to model this relationships we'll create Path s. A Path is an ordered list of task divisions that need to be consecutively done, so until one is completed the next are not actionable, therefore if it get's blocked the whole Path is blocked. graph TD First step --> Second step Second step --> Third step A Task may have many Path s. graph TD subgraph Path 1 Path 1: step 1 --> Path 1: step 2 Path 1: step 2 --> Path 1: step 3 end subgraph Path 2 Path 2: step 1 --> Path 2: step 2 Path 2: step 2 --> Path 2: step 3 end A Path may start from one or more other Path steps graph TD subgraph Path 1 Path 1: step 1 --> Path 1: step 2 Path 1: step 2 --> Path 1: step 3 end subgraph Path 2 Path 1: step 2 --> Path 2: step 1 Path 2: step 1 --> Path 2: step 2 end graph TD subgraph Path 1 Path 1: step 1 --> Path 1: step 2 Path 1: step 2 --> Path 1: step 3 end subgraph Path 2 Path 2: step 1 --> Path 2: step 2 Path 2: step 2 --> Path 2: step 3 end subgraph Path 3 Path 1: step 2 --> Path 3: step 1 Path 2: step 2 --> Path 3: step 1 Path 2: step 1 --> Path 2: step 2 end Path definition \u00b6 A Path will have the next attributes: id_ parent_id : the Task id which this path is related to, whenever there is a change in the Path , the modified attribute of the Task will be changed. type : Either step or subtask , used to fetch the subdivision elements. starting_nodes : Optional[List[str]] If specified, these are the ids of the steps or subtasks that need to be completed before the path can be acted upon. If it's None the parent_id is assumed, and the Path is actionable from the start. Paths TUI \u00b6 The TUI of the paths will show at the top the attributes of the parent task and then a graph with the different paths. The first option is to use a output inspired by git graph : Description: This is the parent task's description --------------------------------------------------------------- [x] Path 1: Step 1 | [x] Path 1: Step 2 | [x] -------------------- [A] ----------------------- [\\] Path 3: Step 1 | Path 1: Step 3 | Path 2: Step 1 - No longer interesting | | [B] Path 1: Step 4 [ ] Path 2: Step 2 - Waiting for X To happen Where: [ ] : Todo step [x] : Done step [B] : Blocked step [A] : Currently active step [\\] : Dead end, won't follow this path Blocked and dead end steps will have a list of reasons why they are in that state. Colors will help: Inactive tasks (done or still not actionable) will be in grey. Active task will be in green. Blocked task will be in yellow. This representation has two main problems that can be difficult to handle the visualization and controls: long task descriptions and many parallel paths. As these are no corner cases, maybe a representation similar to tree is better. [A] This is the parent task's description \u2502 \u251c\u2500\u2500 [B] Path 1: Definition \u2502 \u251c\u2500\u2500 [x] Path 1: Step 1 \u2502 \u251c\u2500\u2500 [x] Path 1: Step 2 \u2502 \u251c\u2500\u2500 [x] Path 1: Step 3 \u2502 \u2514\u2500\u2500 [B] Path 1: Step 4 \u2502 * Waiting for X to happen \u2502 \u251c\u2500\u2500 [A] Path 2: Definition \u2502 \u251c\u2500\u2500 [A] Path 2: Step 1 \u2502 \u251c\u2500\u2500 [ ] Path 2: Step 2 \u2502 \u2514\u2500\u2500 [ ] Path 2: Step 3 \u2502 \u251c\u2500\u2500 [ ] Path 2.1: Step 1 \u2502 \u2514\u2500\u2500 [ ] Path 2.1: Step 2 \u2502 \u2514\u2500\u2500 [\\] Path 3: Definition * No longer interesting If a task has only one path, a simplified version will be: [B] This is the parent task's description \u251c\u2500\u2500 [x] Path 1: Step 1 \u251c\u2500\u2500 [x] Path 1: Step 2 \u251c\u2500\u2500 [x] Path 1: Step 3 \u2514\u2500\u2500 [B] Path 1: Step 4 * Waiting for X to happen The only downside of this visualization is that we won't be able to represent a path that depends on more than one path. Compared with the other representation, the downside is neglectible, so we'll start with this representation. The upsides, is that the interface has only one column, instead of the undefined number of the first visualization, which makes the coding of the interface much more simple. The state of the path is defined by the state of it's subelements: If all elements are in state done , the path is in state done . If all elements are in state blocked , the path is in state blocked . If one element is in state active , the path is in state active . If one element is in state open , the path is in state open . Controls \u00b6 The user will be able to interact with the Paths TUI through: jklh : to move between the elements and the paths d : Toggle element state from done to todo. \\ : Toggle element state from dead end to todo. b : Toggle element state from blocked to todo. A : Toggle element state from active to todo. D : Delete the element a : Add an element below the highlighted one. It uses the task creation TUI or the step creation TUI. p : Start a new path from the highlighted element h : Toggle the hiding of completed and dead end elements m : Toggle the moving mode. Moving mode will move the highlighted element with jklh within the path or to adjacent paths. e : Edit the highlighted element description. enter : Enter the Task TUI. If it's a step, do nothing zc : Fold current path zM : Fold all paths zo : Unfold current path zO : Unfold all paths v : Enter in visual mode, to select a group of elements and perform an action over them. E : Extract element or elements to a new task. Subtasks CLI interface \u00b6 Get inspiration in grit . Decision \u00b6 Consequences \u00b6","title":"Status"},{"location":"adr/0xx-subtasks-and-steps/#status","text":"Draft","title":"Status"},{"location":"adr/0xx-subtasks-and-steps/#context","text":"We need to define how are we going to split long tasks into smaller actionable steps in an user friendly way.","title":"Context"},{"location":"adr/0xx-subtasks-and-steps/#proposals","text":"There are two use cases: Big tasks that need to be subdivided in smaller tasks to enter a sprint Small enough tasks to enter the sprint, where the user wants to define the small steps required to complete it. Creating a task requires time to fill up it's attributes: assign an area, tags, priority, description... It also adds time to the overall management of all the tasks. This time investment makes sense only for the first case, the small steps often change and don't have the size to be managed with the rest of the tasks.","title":"Proposals"},{"location":"adr/0xx-subtasks-and-steps/#task-division","text":"This idea supports the plan to subdivide a task at two levels: subtasks and steps. Subtasks will be Task entities so that we can do infinite levels of subtask nesting. To achieve this we'll need to change the Task model to add an attribute parent_id that allows us to relate a task with its subtasks. Steps will be a new simpler entity Step with only parent_id , created , closed , state and description , so that it will be easier to create, potentially only the description will be filled by the user, and as it follows the same structure it will be easy to promote to Task if needed. Step s don't have identity by themselves, they are tightly coupled with a task, that's why they could be saved under the steps attribute of the Task . Until repository-orm supports nested objects, we'll only be able to use the TinyDB and Fake repositories. The benefit from being a task attribute is that recurrent tasks will inherit them automatically. In the first iteration to simplify the logic: Steps and subtasks will be mutually exclusive. Recurrent tasks won't support subtasks, as the children breed won't be trivial.","title":"Task division"},{"location":"adr/0xx-subtasks-and-steps/#paths","text":"Sometimes the task divisions (steps or subtasks) are related between each other, to model this relationships we'll create Path s. A Path is an ordered list of task divisions that need to be consecutively done, so until one is completed the next are not actionable, therefore if it get's blocked the whole Path is blocked. graph TD First step --> Second step Second step --> Third step A Task may have many Path s. graph TD subgraph Path 1 Path 1: step 1 --> Path 1: step 2 Path 1: step 2 --> Path 1: step 3 end subgraph Path 2 Path 2: step 1 --> Path 2: step 2 Path 2: step 2 --> Path 2: step 3 end A Path may start from one or more other Path steps graph TD subgraph Path 1 Path 1: step 1 --> Path 1: step 2 Path 1: step 2 --> Path 1: step 3 end subgraph Path 2 Path 1: step 2 --> Path 2: step 1 Path 2: step 1 --> Path 2: step 2 end graph TD subgraph Path 1 Path 1: step 1 --> Path 1: step 2 Path 1: step 2 --> Path 1: step 3 end subgraph Path 2 Path 2: step 1 --> Path 2: step 2 Path 2: step 2 --> Path 2: step 3 end subgraph Path 3 Path 1: step 2 --> Path 3: step 1 Path 2: step 2 --> Path 3: step 1 Path 2: step 1 --> Path 2: step 2 end","title":"Paths"},{"location":"adr/0xx-subtasks-and-steps/#path-definition","text":"A Path will have the next attributes: id_ parent_id : the Task id which this path is related to, whenever there is a change in the Path , the modified attribute of the Task will be changed. type : Either step or subtask , used to fetch the subdivision elements. starting_nodes : Optional[List[str]] If specified, these are the ids of the steps or subtasks that need to be completed before the path can be acted upon. If it's None the parent_id is assumed, and the Path is actionable from the start.","title":"Path definition"},{"location":"adr/0xx-subtasks-and-steps/#paths-tui","text":"The TUI of the paths will show at the top the attributes of the parent task and then a graph with the different paths. The first option is to use a output inspired by git graph : Description: This is the parent task's description --------------------------------------------------------------- [x] Path 1: Step 1 | [x] Path 1: Step 2 | [x] -------------------- [A] ----------------------- [\\] Path 3: Step 1 | Path 1: Step 3 | Path 2: Step 1 - No longer interesting | | [B] Path 1: Step 4 [ ] Path 2: Step 2 - Waiting for X To happen Where: [ ] : Todo step [x] : Done step [B] : Blocked step [A] : Currently active step [\\] : Dead end, won't follow this path Blocked and dead end steps will have a list of reasons why they are in that state. Colors will help: Inactive tasks (done or still not actionable) will be in grey. Active task will be in green. Blocked task will be in yellow. This representation has two main problems that can be difficult to handle the visualization and controls: long task descriptions and many parallel paths. As these are no corner cases, maybe a representation similar to tree is better. [A] This is the parent task's description \u2502 \u251c\u2500\u2500 [B] Path 1: Definition \u2502 \u251c\u2500\u2500 [x] Path 1: Step 1 \u2502 \u251c\u2500\u2500 [x] Path 1: Step 2 \u2502 \u251c\u2500\u2500 [x] Path 1: Step 3 \u2502 \u2514\u2500\u2500 [B] Path 1: Step 4 \u2502 * Waiting for X to happen \u2502 \u251c\u2500\u2500 [A] Path 2: Definition \u2502 \u251c\u2500\u2500 [A] Path 2: Step 1 \u2502 \u251c\u2500\u2500 [ ] Path 2: Step 2 \u2502 \u2514\u2500\u2500 [ ] Path 2: Step 3 \u2502 \u251c\u2500\u2500 [ ] Path 2.1: Step 1 \u2502 \u2514\u2500\u2500 [ ] Path 2.1: Step 2 \u2502 \u2514\u2500\u2500 [\\] Path 3: Definition * No longer interesting If a task has only one path, a simplified version will be: [B] This is the parent task's description \u251c\u2500\u2500 [x] Path 1: Step 1 \u251c\u2500\u2500 [x] Path 1: Step 2 \u251c\u2500\u2500 [x] Path 1: Step 3 \u2514\u2500\u2500 [B] Path 1: Step 4 * Waiting for X to happen The only downside of this visualization is that we won't be able to represent a path that depends on more than one path. Compared with the other representation, the downside is neglectible, so we'll start with this representation. The upsides, is that the interface has only one column, instead of the undefined number of the first visualization, which makes the coding of the interface much more simple. The state of the path is defined by the state of it's subelements: If all elements are in state done , the path is in state done . If all elements are in state blocked , the path is in state blocked . If one element is in state active , the path is in state active . If one element is in state open , the path is in state open .","title":"Paths TUI"},{"location":"adr/0xx-subtasks-and-steps/#controls","text":"The user will be able to interact with the Paths TUI through: jklh : to move between the elements and the paths d : Toggle element state from done to todo. \\ : Toggle element state from dead end to todo. b : Toggle element state from blocked to todo. A : Toggle element state from active to todo. D : Delete the element a : Add an element below the highlighted one. It uses the task creation TUI or the step creation TUI. p : Start a new path from the highlighted element h : Toggle the hiding of completed and dead end elements m : Toggle the moving mode. Moving mode will move the highlighted element with jklh within the path or to adjacent paths. e : Edit the highlighted element description. enter : Enter the Task TUI. If it's a step, do nothing zc : Fold current path zM : Fold all paths zo : Unfold current path zO : Unfold all paths v : Enter in visual mode, to select a group of elements and perform an action over them. E : Extract element or elements to a new task.","title":"Controls"},{"location":"adr/0xx-subtasks-and-steps/#subtasks-cli-interface","text":"Get inspiration in grit .","title":"Subtasks CLI interface"},{"location":"adr/0xx-subtasks-and-steps/#decision","text":"","title":"Decision"},{"location":"adr/0xx-subtasks-and-steps/#consequences","text":"","title":"Consequences"},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences. graph TD 001[001: Deprecation of Fulids] 00X[00X: Subtasks and steps] 00Y[00X: Agenda] click 001 \"https://lyz-code.github.io/pydo/adr/001-change-id-from-str-to-int\" _blank click 00X \"https://lyz-code.github.io/pydo/adr/0xx-subtasks-and-steps\" _blank click 00Y \"https://lyz-code.github.io/pydo/adr/0xx-agenda\" _blank 001:::accepted 00X:::draft 00Y:::draft classDef draft fill:#CDBFEA; classDef proposed fill:#B1CCE8; classDef accepted fill:#B1E8BA; classDef rejected fill:#E8B1B1; classDef deprecated fill:#E8B1B1; classDef superseeded fill:#E8E5B1;","title":"Adr"},{"location":"developing/database_schema/","text":"The schema is defined in the models.py file through SQLAlchemy objects. To visualize the schema we've used wwwsqldesigner through their hosted instance . We load the database_schema.xml to modify it and save it back as xml in the repo.","title":"Database Schema"}]}